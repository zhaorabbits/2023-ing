# MySQL

[TOC]

## 基础概念







## 高频面试题

1. 项目中有没有涉及到一些MySQL数据库表的设计的工作？数据库设计相关（ 一个表（存一个人的积分），一个表（存一些货品），如果产生冲突怎么办 ）

   

2. . MySQL索引用来做什么的，用的什么数据结构？ MySQL 索引（B-Tree索引、哈希索引、R-Tree索引、全文索引等等）

   索引是一种用于**快速查询和检索数据的数据结构**，其本质可以看成是一种排序好的数据结构。

   常见的索引底层数据结构有：B树、B+树、Hash索引、红黑树。

   - Hash表：

     - 快速检索数据，接近O（1）

     - Hash索引不支持顺序和范围查询（排序或进行范围查询），并且IO只能取一个

       ```
       SELECT * FROM tb1 WHERE id < 500;
       ```

   - B树：B-树，全称 多路平衡查找树

   MySQL中，无论是Innodb还是MyIsam，都是用了B+树作为索引结构

   索引的优缺点：

   - 优点：
     - 使用索引可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建索引的最主要的原因
     - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
   - 缺点：
     - 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL的执行效率
     - 索引需要使用物理文件存储，也会耗费一定的空间

   **大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。**

   

3. MySQL引擎，InnoDB和MyISAM区别？索引上的区别是什么?



​		MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不一样：

			- MyISAM引擎中，B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”
			- InnDB引擎中，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”，而其余的索引都被称为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可去除数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调字段作为主键，这样会造成主索引频繁

4. 什么是数据库事务？事务特点？怎么实现的？ACID举个例子？

5. 事务的持久性如何保证？

   redo log 和bin log

   MySQL为什么要用redo log？

   缓冲区刷盘不是每次一点改动就立即执行的，为了执行性能高，会将多次改动结果一起刷盘，为了防止还没刷盘时MySQL宕机导致数据丢失，所以用了redo log，将改动同时写在redo log

   追问redo log也是磁盘中的文件，也要写盘，为什么性能会提高?

   追问为什么不用bin log来实现崩溃恢复?

6. 事务的隔离性如何保证（MVCC+锁，分别讲实现原理，还有间隙锁）

7. 聚簇索引和非聚簇索引区别？

   - 聚簇索引：**索引结构和数据一起存放的索引**，InnDB 中的主键索引就属于聚簇索引
     - 优点：
       - 查询速度快，因为整个B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的IO操作。
       - 对于主键的排序查找和范围查找速度非常快
     - 缺点：
       - 因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢
       - 更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改的代价肯定时较大的，所以对于主键索引来说，主键一般都是不可被修改的
   - 非聚簇索引：**索引结构和数据分开存放的索引**，二级索引（辅助索引）就属于非聚簇索引。MySQL的MyISAM引擎，不管是主机那还是非主键，使用的都是非聚簇索引
     - 优点：
       - 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点不存放数据
     - 缺点：
       - 依赖于有序的数据：和聚簇索引一样
       - 可能会二次查询（回表）：这应该是非聚簇索引最大的缺点，当查到索引对应的指针或者主键后，可能还需要根据指针或主键再到数据文件或表中查询。

8. b树和b+树的区别？

   - B树的所有节点既存放键key,也存放数据（data），而B+树只有叶子节点存放key和data，其它内节点只存放key。
   - B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点
   - B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显

9. 索引失效的场景？亿级为什么达到了瓶颈？

   索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

   - 使用select * 进行查询
   - 创建了组合索引，但查询条件未遵守最左匹配原则
   - 在索引列上进行计算、函数、类型转换等操作
   - 以%开头的like查询比如 like ‘%abc’
   - 查询条件中使用or，且or的前后条件中有一个列没有索引，涉及的索引都不会被使用到

10. 索引的设计原则（正确使用索引的建议）

    - 选择合适的字段创建索引
      - 不为NULL的字段：索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化
      - 被频繁查询的字段：创建索引的字段应该是查询操作非常频繁的字段
      - 被作为条件查询的字段：被作为WHERE条件查询的字段，应该被考虑建立索引
      - 频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
      - 被经常频繁用于连接的字段：
    - 被频繁更新的字段应该慎重建立索引
    - 限制每张表上的索引数量
      - 索引并不是越多越好，建议单张表索引不超过5个！索引可以提高效率同样可以降低效率。
      - 索引可以增加查询效率，但同样会降低插入和更新的效率，甚至有些情况下会降低查询效率。
    - 尽可能的考虑建立联合索引而不是单列索引
      - 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一棵B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引是，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引了，那么将会节约很大磁盘空间，且修改的数据效率也会提升。
    - 注意避免冗余索引
    - 字符串类型的字段使用前缀索引代替普通索引
      - 前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引代替普通索引
    - 避免索引失效
    - 删除长期未使用的索引
    - 知道如何分析语句是否走索引查询
      - 可以使用EXPLAIN命令来分析SQL的执行计划，这样就知道语句是否命中索引了。执行计划是指一条sql语句在经过MySQL查询优化器的优化后，具体的执行方式。
      - EXPLAIN并不会执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。

11. mysql回表？

    InnoDB从普通索引无法直接定位行记录，那普通索引的查询过程，通常需要扫描两边索引树。所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

    InnoDB聚集索引的叶子节点存储行记录，因此，InnoDB必要有，且只有一个聚集索引：

    - 如果表定义了主键，则pk就是聚集索引
    - 如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列就是聚集索引
    - 否则，InnoDB会创建一个隐藏的row-id作为聚集索引。

    将单列索引升级为联合索引，即可避免回表。

    如何实现索引覆盖？将查询的字段，建立到联合索引里去。

12. 怎么对sql语句进行的优化？优化步骤是什么？

    

13. 慢查询日志怎么开启?具体的命令？

14. explain怎么分析？看哪些字段？type有哪些类型？你们优化到那个类型？

15. mysql的主从复制？

16. 怎么解决redis与mysql 的数据一致性？

17. 分库分表怎么实现？

18. 倒排索引和正向索引的区别？

19. mysql的锁机制，rr怎么解决幻读的？完全解决了吗？死锁？

20. MySQL的两阶段提交（具体讲解，如果中间几个阶段分别崩溃怎么办）？

    - redo log（重做日志）：让InnoDB存储引擎拥有了崩溃恢复能力

    - binlog（归档日志）：保证了MySQL集群架构的数据一致性；

      在执行更新语句过程中，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事物时写入，所以redo log与binlog的写入实际不一样。
      
      **为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。将redo log 的写入折成两个步骤prepare和commit，这就是两阶段提交**。
      
      写入binlog时异常：查看是否存在对应的binlog，没有就回归
      
      redo log设置为commit时异常：如果为commit，直接提交，否则，查看是否存在对应的binlog，有的话提交。

21. MySQL的关键字 in 和 or  的区别？

    ```
    in 与 or 的区别主要为执行效率方面:
    
        in 或 or 在字段有添加索引的情况下，查询很快，两者查询速度没有什么区别；
    
        in 或 or 在字段没有添加索引的情况下,所连接的字段越多(1 or 2 or 3 or 4 or …)，or 比 in
    
        的查询效率低很多
    
     SELECT * FROM tbName WHERE KEY IN (a1, a2, ...... , an); 
    
    in 先将 a1, a2, …, an 变成二叉搜索树，用过二叉树查找，时间复杂度为O(LogN);
    
     
    
    SELECT * FROM tbName WHERE KEY = a1 OR KEY = a2 OR ...... OR KEY = an;
    
    or 是从 a1 匹配，匹配失败，去匹配 a2，直到匹配成功或者一个都匹配不上,时间复杂度是 O(N);
    ```

    

22. MySQL事务隔离级别有哪些，会产生哪些问题，MySQL默认的隔离级别是什么?

23. MySQL如何实现可重复读？MVCC的底层原理？

24. MVCC原理？

25. MVCC的如何判断行记录对某一个事务是否可见?

26. MVCC在四种隔离级别中如何实现（讲了只能在RC和RR下实现，追问RC和RR两者实现的区别）?

27. 索引查找的时间复杂度是多少?

28. Mysql异常宕机后，数据一定丢失吗？（redolog）?

    不一定。因为在事务执行过程redo log记录是会写入redo log buffer中，则和谐redo log记录会被后弦线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当redo log buffer 占用的空间即将到达innodb_log_buffer_size一半的时候，后台线程会主动刷盘。

    - innodb_flush_log_at_trx_commit = 0: 会损失1秒内的数据
    - innodb_flush_log_at_trx_commit = 1: 提交事务成功后，会主动刷盘，不会有任何数据丢失
    - innodb_flush_log_at_trx_commit = 2:提交事务成功后，redo log buffer内容会写入page cache（文件系统缓存），如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有一秒的数据丢失。

29. 什么情况下会丢失？

    操作都是基于内存的，没有刷盘的时候宕机了，会丢失。

30. innodb可以没有主键吗?

31. MySQL 查询语句的执行流程？

32. Mysql中常用的函数，数据类型转换可能存在的问题？

33. mysql如何确认我是否命中索引？

34. AB两张表 如何将B表的列复制到A表？

35. 什么是游标？

36. MySQL的锁粒度？

37. MySQL索引为啥用B+树，不用普通二叉树？

38. left join 和 right join的区别？

39. 一条sql的执行过程？

    

40. 唯一索引和主键索引的区别？

    - 主键索引：加速查询+列值唯一（不可以有NULL）+表中只有一个主键索引
    - 唯一索引：加速查询+列值唯一（可以有NULL)

41. 什么是组合索引？

    组合索引，也叫联合索引、复合索引。使用表中的多个字段创建索引。

    ```
    以score 和name 两个字段建立联合索引
    alter table "cus_order" ADD INDEX id_score_name(score, name);
    
    联合索引的B+树是先按score进行排序，然后再score相同的情况再按name字段排序
    ```

    

42. 项目表之间的关系？一对一，一对多

43. 最左匹配原则？a,b,c问题？

    https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ

    联合索引的最左匹配原则会一直向右匹配直到遇到范围查询（<,>）就会停止匹配，也就是范围查询的字段可以用到联合索引，但是再范围查询字段后面的字段无法用到联合索引。但是，对于>=、<=、BETWEEN、like前缀匹配这四种范围查询，并不会停止匹配。

    ***利用索引的前提是索引里的key是有序的。（底层：二分查找）***

    ```
    //需要注意的是，因为有查询优化器，所以a字段再where子句的顺序并不重要。
    如果创建了一个（a, b, c）联合索引
    可以利用联合索引：
    where a=1；
    where a=1 and b=2 and c=3；
    where a=1 and b=2；
    联合索引失效：
    where b=2；
    where c=3；
    where b=2 and c=3；
    上面这些查询条件之所以会失效，是因为（a,b,c）联合索引，是先按a排序，在a相同的情况下再按b排序，在b相同的情况下再按c排序。所以，b和c是全局无序，局部相对有序的，这样再没有遵循最左匹配原则的情况下，是无法利用到索引的。
    
    select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
    Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。
    可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，通过 key_len 我们可以知道优化器具体使用了多少个字段的查询条件来形成扫描区间的边界条件。
    a 和 b 都是 int 类型且不为 NULL 的字段（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节）
    ```

    

44. 怎么解决大key问题？

45. 我要查全量的，写个分页？怎么优化分页？

46. MySQL为什么不用跳表？跳表的原理？

47. MySQL范围查找并排序的详细过程？如果数据很大，内存很小怎么办？如果有limit呢？

48. MySQL一张表能存储多少数据？怎么计算的？

49. 聚合函数，口述统计学生的平均成绩sql？

50. 如果我的type是个枚举类型？索引如何优化？

51. Mysql表有哪些种类？有哪些字段类型？

52. 文件里面2亿个数，找到最大100个？

53. 系统的文件日志，几千万条，怎么找出出现最多的ip地址？

54. 数据库的三范式？

55. 快照读和当前读的区别？

56. 除了insert外，还有哪些sql语句会加锁？

57. 主键索引和辅助索引(二级索引) 都会加间隙锁吗？

58.  哈希算法有几种、一次性哈希、如何判断这个哈希算法优秀 ？

59. 索引的底层结构是啥？

60. 我要查全量的，写个分页：select * from hotel limit 50, ?*50;

61. 怎么优化分页？

62. 如果我的type是个枚举类型？索引如何优化？

63. 

